# Move Zeroes 完整分析文档 📊

## 问题描述

**LeetCode 283. Move Zeroes**

给定一个整数数组 `nums`，将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**注意：** 必须在原数组上操作，不能拷贝额外的数组。

### 示例

**示例 1:**
```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**
```
输入: nums = [0]
输出: [0]
```

### 约束条件

- `1 <= nums.length <= 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

### Follow-up

**能否最小化操作的总次数？**

## 解法分析

### 1. 暴力解法 - 逐个移动法 🔄

#### 算法思路
从后往前遍历数组，找到每个 0：
1. 当找到 0 时，将其后面的所有元素向前移动一位
2. 将最后一个位置设为 0
3. 从后往前遍历避免了重复处理的问题

#### 代码实现
```c
void moveZeroes(int* nums, int numsSize) {
    // 从后往前遍历，找到每个0
    for (int i = numsSize - 1; i >= 0; i--) {
        if (nums[i] == 0) {
            // 将0后面的所有元素向前移动一位
            for (int j = i; j < numsSize - 1; j++) {
                nums[j] = nums[j + 1];
            }
            // 将最后一个位置设为0
            nums[numsSize - 1] = 0;
        }
    }
}
```

#### 复杂度分析
- **时间复杂度：** O(n²) - 最坏情况下每个 0 都要遍历整个数组
- **空间复杂度：** O(1) - 只使用了常数额外空间

#### 优缺点
✅ **优点：** 思路直观，容易理解，保持相对顺序  
❌ **缺点：** 时间复杂度较高，操作次数多

---

### 2. 优化解法 - 快慢指针法 🏃‍♂️

#### 算法思路
使用两个指针 `slow` 和 `fast`：
1. `slow` 指针指向下一个非零元素应该放置的位置
2. `fast` 指针遍历整个数组
3. 当 `fast` 指向非零元素时，将其复制到 `slow` 位置，然后 `slow++`
4. 最后将 `slow` 之后的所有位置设为 0

#### 代码实现
```c
void moveZeroes_two_pointers(int* nums, int numsSize) {
    if (nums == NULL || numsSize <= 1) {
        return;
    }
    
    int slow = 0;
    
    // 第一次遍历：将所有非零元素移动到数组前面
    for (int fast = 0; fast < numsSize; fast++) {
        if (nums[fast] != 0) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    
    // 第二次遍历：将剩余位置设为0
    for (int i = slow; i < numsSize; i++) {
        nums[i] = 0;
    }
}
```

#### 复杂度分析
- **时间复杂度：** O(n) - 只需要遍历数组两次
- **空间复杂度：** O(1) - 只使用了常数额外空间

#### 优缺点
✅ **优点：** 时间复杂度优秀，逻辑清晰  
❌ **缺点：** 需要两次遍历

---

### 3. 最优解法 - 覆盖法 ⚡

#### 算法思路
使用两个指针 `write` 和 `read`：
1. `write` 指针指向下一个非零元素应该写入的位置
2. `read` 指针遍历整个数组
3. 当 `read` 指向非零元素时，将其复制到 `write` 位置，然后 `write++`
4. 最后将 `write` 之后的所有位置设为 0

#### 代码实现
```c
void moveZeroes_optimal(int* nums, int numsSize) {
    if (nums == NULL || numsSize <= 1) {
        return;
    }
    
    int write = 0;
    
    // 一次遍历：将所有非零元素移动到数组前面
    for (int read = 0; read < numsSize; read++) {
        if (nums[read] != 0) {
            // 只有当read != write时才需要复制，避免不必要的操作
            if (read != write) {
                nums[write] = nums[read];
            }
            write++;
        }
    }
    
    // 将剩余位置设为0
    for (int i = write; i < numsSize; i++) {
        nums[i] = 0;
    }
}
```

#### 复杂度分析
- **时间复杂度：** O(n) - 只需要遍历数组一次
- **空间复杂度：** O(1) - 只使用了常数额外空间

#### 优缺点
✅ **优点：** 时间复杂度最优，操作次数最少  
✅ **优点：** 符合 LeetCode 的 follow-up 要求  
❌ **缺点：** 代码稍微复杂一些

---

## 性能对比 📈

| 解法 | 时间复杂度 | 空间复杂度 | 操作次数 | 推荐指数 |
|------|------------|------------|----------|----------|
| 暴力解法 | O(n²) | O(1) | 最多 n² | ⭐⭐ |
| 快慢指针法 | O(n) | O(1) | 2n | ⭐⭐⭐⭐ |
| 覆盖法 | O(n) | O(1) | n | ⭐⭐⭐⭐⭐ |

## 测试用例覆盖 🧪

### 基础测试用例
1. **标准用例：** `[0,1,0,3,12]` → `[1,3,12,0,0]`
2. **单个元素：** `[0]` → `[0]`
3. **无零元素：** `[1,2,3,4,5]` → `[1,2,3,4,5]`

### 边界测试用例
4. **多个连续零：** `[0,0,0,1,2,3]` → `[1,2,3,0,0,0]`
5. **交替出现：** `[1,0,2,0,3,0,4]` → `[1,2,3,4,0,0,0]`
6. **全部为零：** `[0,0,0,0,0]` → `[0,0,0,0,0]`

## 算法选择建议 💡

### 面试场景
- **首选：** 覆盖法（最优解法）
- **备选：** 快慢指针法（思路清晰）

### 学习场景
- **入门：** 暴力解法（理解基本思路）
- **进阶：** 快慢指针法（掌握双指针技巧）
- **精通：** 覆盖法（优化思维）

## 相关题目 🔗

- **Remove Element (27)** - 移除指定元素
- **Remove Duplicates from Sorted Array (26)** - 移除重复元素
- **Sort Colors (75)** - 三色排序问题

## 总结 🎯

Move Zeroes 是一个经典的数组操作问题，通过三种不同的解法展示了算法优化的过程：

1. **暴力解法** 帮助我们理解问题的基本思路
2. **快慢指针法** 展示了双指针技巧的应用
3. **覆盖法** 体现了算法优化的极致追求

**关键学习点：**
- 双指针技巧的应用
- 原地操作数组的方法
- 算法优化的思路和技巧
- 时间复杂度与空间复杂度的权衡

通过这个问题的学习，可以掌握数组操作的核心技巧，为后续更复杂的算法问题打下坚实基础。
